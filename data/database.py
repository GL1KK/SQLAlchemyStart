from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession
from sqlalchemy.orm import Session, sessionmaker, DeclarativeBase
from sqlalchemy import URL, create_engine, text, String
from config import settings
import asyncio
from typing import Annotated

# Создание синхронного движка SQLAlchemy
sync_engine = create_engine(
    url=settings.DATABASE_URL_psyconf, # Указываем URL для подключения к синхронной базе данных (например, PostgreSQL, SQLite).
    echo=True, # Если True, SQLAlchemy будет выводить в консоль все сгенерированные SQL-запросы (полезно для отладки).
    pool_size=5, # Устанавливаем начальный размер пула соединений (количество одновременно активных подключений к БД).
    max_overflow=10, # Определяем максимальное количество дополнительных соединений, которые могут быть созданы при перегрузке пула.
)

# Создание асинхронного движка SQLAlchemy (для асинхронной работы с базой данных)
async_engine = create_async_engine(
    url=settings.DATABASE_URL_asyncpg, # Указываем URL для подключения к асинхронной базе данных (например, PostgreSQL с asyncpg).
    echo=False, # Отключаем вывод SQL-запросов для асинхронного движка.
    pool_size=5, # Устанавливаем начальный размер пула асинхронных соединений.
    max_overflow=10, # Определяем максимальное количество дополнительных асинхронных соединений.
)

# Создание фабрики сессий для синхронной работы с базой данных
sync_session_factory = sessionmaker(sync_engine) # 'sessionmaker' создает фабрику, которая при вызове генерирует объекты сессий,
                                               # использующие указанный синхронный движок. Сессия управляет всеми операциями
                                               # с базой данных для определенного "рабочего процесса".

# Создание фабрики сессий для асинхронной работы с базой данных
async_session_factory = async_sessionmaker(async_engine) # Аналогично 'sessionmaker', но для асинхронного движка.
                                                     # Асинхронные сессии используются с ключевыми словами 'async with'.

# Ограничение на длину строкового поля (использование typing.Annotated)
str_256 = Annotated[str, 256] # 'Annotated' используется для добавления метаданных к типам.
                               # В данном случае, мы создаем аннотированный тип 'str_256', указывая,
                               # что это строка с максимальной длиной 256 символов.
                               # SQLAlchemy будет использовать эту информацию при создании схемы базы данных.

# Базовый класс для определения ORM моделей (наследуются от него ваши таблицы)
class Base(DeclarativeBase):
    """
    Базовый класс для декларативного определения ORM моделей SQLAlchemy.
    Все ваши классы таблиц (например, WorkerOrm, ResumesOrm) должны наследоваться от этого класса.
    Он предоставляет механизм для определения таблиц как классов Python.
    """
    type_annotation_map = {
        str_256: String(256) # Указываем SQLAlchemy, что когда встречается аннотация типа 'str_256',
                             # соответствующий столбец в базе данных должен быть типа String с длиной 256.
    }
    # def __repr__(self):
    #     cols = [{f"{col}={getattr(self, col)}" for col in self.__table__.columns.keys()}]
    #     return f"<{self.__class__.__name__} {','.join(str(i) for i in cols)}>" 

    def __repr__(self):
        """
        Переопределяет стандартное строковое представление объекта,
        которое используется при вызове print() для объекта или при его отображении в отладчике.
        Это помогает сделать отладку и логирование более информативными,
        показывая ключевые поля объекта.
        """
        cols = [] # Создаем пустой список для хранения строковых представлений столбцов.
        # Итерируем по всем столбцам таблицы, к которой привязана эта ORM-модель.
        # `self.__table__.columns.keys()` возвращает список имен столбцов.
        for idx, col in enumerate(self.__table__.columns.keys()):
            # Проверяем, должен ли столбец быть включен в repr:
            # 1. Если имя столбца явно указано в `self.repr_cols` ИЛИ
            # 2. Если индекс столбца меньше `self.repr_cols_nums` (то есть, это один из первых N столбцов).
            if col in self.repr_cols or idx < self.repr_cols_nums:
                # Если условие выполняется, форматируем строку в виде "имя_столбца=значение_столбца"
                # `getattr(self, col)` динамически получает значение атрибута (столбца) по его имени.
                cols.append(f"{col}={getattr(self, col)}")
        # Формируем финальную строку repr.
        # - `<{self.__class__.__name__}`: Начинаем с имени класса (например, "<WorkerOrm").
        # - `{','.join(str(i) for i in cols)}`: Объединяем все отформатированные строки столбцов
        #   в одну строку, разделяя их запятыми.
        # - `>`: Закрываем угловую скобку.
        return f"<{self.__class__.__name__} {','.join(str(i) for i in cols)}>"